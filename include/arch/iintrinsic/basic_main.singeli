# This file should not be included directly:
# instead use arch/iintrinsic/basic or arch/iintrinsic/basic_strict
# which define whether fills should be used
local {
  include 'skin/c'
  oper ~~ reinterpret infix right 55
  oper ** make_const_vector infix right 55
  def num{x} = is{'number',kind{x}}

  def fmt_p{T, ...s} = {
    if (isfloat{T}) {
      if (width{T}==32) 'ps' else 'pd'
    } else {
      def sgn = if (tuplen{s}==1) tupsel{0,s} else issigned{T}
      merge{'ep', if (sgn) 'i' else 'u', fmtnat{width{T}}}
    }
  }
  def fmt_p{T, w & isint{T} & w>1} = merge{'si', fmtnat{w}}
  def intrin{name, V, ...s} = {
    def w = width{V}
    def fw = if (w<=128) '' else fmtnat{w}
    merge{'_mm', fw, '_', name, '_', fmt_p{eltype{V}, ...s}}
  }
  def intrin_b{name, V} = intrin{name, V, width{V}}

  def sse{V} = 128==width{V}
  def avx{V} = 256==width{V}
  def sse_avx{V} = __or{...tup{128,256}==width{V}}
  def ef{V} = isfloat{eltype{V}}
  def ei{V} = isint  {eltype{V}}
  def eu{V} = 'u'==quality{eltype{V}}
  def ew{V} = width  {eltype{V}}

  def change_qual{V,q} = [vcount{V}]primtype{q, ew{V}}
  def uns = change_qual{.,'u'}
  def sgn = change_qual{.,'i'}

  def go{V} = if ('vector'==typekind{V}) u1!=eltype{V} else 0
}

def make_const_vector{V, x:eltype{V}} = emit{V, merge{intrin{'set1',V}, if (eltype{V}==i64) 'x' else ''}, x}
def make_const_vector{V, x:eltype{V} & eu{V}} = { def I=sgn{V}; V~~I**eltype{I}~~x }
def make_const_vector{V, x & num{x}} = V**cast{eltype{V}, x}

# Multi-instruction fills; slowest ones go first
local def fill = _iintrinsic_use_fill
def __min{a:V, b:V & fill & go{V} & has_gt{V}} = { c:=V~~(a<b); (a&c) | __andnot{b,c} }
def __max{a:V, b:V & fill & go{V} & has_gt{V}} = { c:=V~~(a>b); (a&c) | __andnot{b,c} }
def __max{a:V, b:V & fill & go{V} & has_satur{V} & eu{V}} = __subs{a,b}+b
def __min{a:V, b:V & fill & go{V} & has_satur{V} & eu{V}} = a-__subs{a,b}
def __lt{a:V, b:V & fill & go{V}} = b>a
def __ge{a:V, b:V & fill & go{V}} = b<=a
def __le{a:V, b:V & fill & go{V}} = ~(a>b)
def __ne{a:V, b:V & fill & go{V}} = ~(b==a)
def __gt{a:V, b:V & fill & go{V} & eu{V} & has_gt{sgn{V}}} = {
  t:= V**(1<<(ew{V}-1))
  def I = sgn{V}; def s{v} = I~~(t^v)
  s{a} > s{b}
}
def __le{a:V, b:V & fill & go{V} & has_minmax{V}} = a==__min{a,b}
def __gt{a:V, b:V & fill & go{V} & ~has_gt{V} & has_minmax{V}} = ~(a<=b)
def __eq{a:V, b:V & fill & go{V} & ei{V} & ew{V}==64} = { def H=[4]u32; t := H~~a == H~~b; V~~(t & emit{H, '_mm_shuffle_epi32', t, 4b2301}) }
def __not{a:V & fill & go{V} & has_bitwise{V}} = a ^ (V ** ~cast{eltype{V},0})

# Single-instruction definitions
def __and   {a:V, b:V & go{V} & has_bitwise{V}} = emit{V, intrin_b{'and'   ,V}, a, b}
def __or    {a:V, b:V & go{V} & has_bitwise{V}} = emit{V, intrin_b{'or'    ,V}, a, b}
def __xor   {a:V, b:V & go{V} & has_bitwise{V}} = emit{V, intrin_b{'xor'   ,V}, a, b}
def __andnot{a:V, b:V & go{V} & has_bitwise{V}} = emit{V, intrin_b{'andnot',V}, b, a}

def __add {a:V, b:V & go{V} & has_arith{V}}  = emit{V, intrin{'add', V,1}, a, b}
def __sub {a:V, b:V & go{V} & has_arith{V}}  = emit{V, intrin{'sub', V,1}, a, b}
def __adds{a:V, b:V & go{V} & has_satur{V}}  = emit{V, intrin{'adds',V  }, a, b}
def __subs{a:V, b:V & go{V} & has_satur{V}}  = emit{V, intrin{'subs',V  }, a, b}
def __min {a:V, b:V & go{V} & has_minmax{V}} = emit{V, intrin{'min', V  }, a, b}
def __max {a:V, b:V & go{V} & has_minmax{V}} = emit{V, intrin{'max', V  }, a, b}
def __mul {a:V, b:V & go{V} & has_mul{V}}    = emit{V, intrin{if (ef{V}) 'mul' else 'mullo', V,1}, a, b}

def __shl{a:V, b & num{b} & go{V} & has_shift{V}} = emit{V, intrin{'slli',V,1}, a, b}
def __shr{a:V, b & num{b} & go{V} & has_rsh  {V}} = emit{V, intrin{if (issigned{eltype{V}}) 'srai' else 'srli',V,1}, a, b}
def __shl_hom{a:V, b:[2]u64 & go{V} & has_shift{V}} = emit{V, intrin{'sll',V,1}, a, b}
def __shr_hom{a:V, b:[2]u64 & go{V} & has_rsh  {V}} = emit{V, intrin{if (issigned{eltype{V}}) 'sra' else 'srl',V,1}, a, b}
def __shl{a:V, b:U & go{V} & U==uns{V} & has_vshift{V}} = emit{V, intrin{'sllv',V,1}, a, b}
def __shr{a:V, b:U & go{V} & U==uns{V} & has_vrsh  {V}} = emit{V, intrin{if (issigned{eltype{V}}) 'srav' else 'srlv',V,1}, a, b}

def __eq{a:V, b:V & go{V} & has_eq{V}} = emit{uns{V}, intrin{'cmpeq',V,1}, b, a}
def __gt{a:V, b:V & go{V} & has_gt{V}} = emit{uns{V}, intrin{'cmpgt',V  }, a, b}
def __lt{a:V, b:V & go{V} & has_gt{V}} = emit{uns{V}, intrin{'cmpgt',V  }, b, a}

local def cmp_flt{V, a, b, name, num} = {
  def c = if (sse{V}) emit{V, intrin{merge{'cmp',name}, V}, a, b}
          else        emit{V, intrin{'cmp', V}, a, b, num}
  # Return unsigned int even though intrinsics use floats
  def U = uns{V}
  emit{U, intrin_b{merge{'cast',fmt_p{eltype{V}}}, U}, c}
}
def __eq{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'eq' ,  0}
def __ne{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'neq',  4}
def __gt{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'gt' , 30}
def __ge{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'ge' , 29}
def __lt{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'lt' , 17}
def __le{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'le' , 18}

def __div{a:V, b:V & go{V} & has_float{V}} = emit{V, intrin{'div', V}, a, b}
def __sqrt {a:V & go{V} & has_float{V}} = emit{V, intrin{'sqrt',  V}, a}
def __floor{a:V & go{V} & has_round{V}} = emit{V, intrin{'floor', V}, a}
def __ceil {a:V & go{V} & has_round{V}} = emit{V, intrin{'ceil',  V}, a}
def __round{a:V & go{V} & has_round{V}} = emit{V, intrin{'round', V}, a}

def __abs    {a:V      & go{V} & has_int_op{V,'SSSE3','i',32}} = emit{V, intrin{'abs' ,V}, a}
def copy_sign{a:V, b:V & go{V} & has_int_op{V,'SSSE3','i',32}} = emit{V, intrin{'sign',V}, a, b}
def __avg    {a:V, b:V & go{V} & has_int_op{V,'SSE2' ,'u',16}} = emit{V, intrin{'avg' ,V}, a, b}

local {
  def has_bitwise{_} = 0  # and, or, xor, andnot
  def has_bitwise{V==[4]f32 & hasarch{'SSE'}} = 1
  def has_bitwise{V & hasarch{'SSE2'} & sse{V}} = 1
  def has_bitwise{V & hasarch{'AVX'} & avx{V} & ef{V}} = 1
  def has_bitwise{V & hasarch{'AVX2'} & avx{V}} = 1

  def has_arith{_} = 0  # add, subtract
  def has_arith{V==[4]f32 & hasarch{'SSE'}} = 1
  def has_arith{V & hasarch{'SSE2'} & sse{V}} = 1
  def has_arith{V & hasarch{'AVX'} & avx{V} & ef{V}} = 1
  def has_arith{V & hasarch{'AVX2'} & avx{V}} = 1

  def has_satur{_} = 0  # saturating add/subtract
  def has_satur{V & hasarch{'SSE2'} & sse{V}} = ew{V}<=16
  def has_satur{V & hasarch{'AVX2'} & avx{V}} = ew{V}<=16

  def has_minmax{_} = 0  # min, max
  def has_minmax{V==[ 4]f32 & hasarch{'SSE' }} = 1
  def has_minmax{V==[ 2]f64 & hasarch{'SSE2'}} = 1
  def has_minmax{V==[ 8]i16 & hasarch{'SSE2'}} = 1
  def has_minmax{V==[16]u8  & hasarch{'SSE2'}} = 1
  def avx_minmax{T} = if (isfloat{T}) 1 else width{T}<=32
  def has_minmax{V & hasarch{'SSE4.1'} & sse{V}} = avx_minmax{eltype{V}}
  def has_minmax{V & hasarch{'AVX'} & avx{V} & ef{V}} = 1
  def has_minmax{V & hasarch{'AVX2'} & avx{V}} = avx_minmax{eltype{V}}

  def has_mul{_} = 0  # same-width multiply (mullo for ints)
  def has_mul{V==[4]f32 & hasarch{'SSE'}} = 1
  def has_mul{V & hasarch{'SSE2'  } & sse{V} & ef{V}} = 1
  def has_mul{V & hasarch{'SSE2'  } & sse{V} & ew{V}==16} = 1
  def has_mul{V & hasarch{'SSE4.1'} & sse{V} & ew{V}==32} = 1
  def has_mul{V & hasarch{'AVX'   } & avx{V} & ef{V}} = 1
  def has_mul{V & hasarch{'AVX2'  } & avx{V} & ew{V}<=32 & ew{V}>=16} = 1

  def has_shift{_} = 0  # shift by scalar
  def has_shift{V & hasarch{'SSE2'} & sse{V} & ei{V} & ew{V}>=16} = 1
  def has_shift{V & hasarch{'AVX2'} & avx{V} & ei{V} & ew{V}>=16} = 1
  def has_rsh{V} = if (eltype{V}==i64) 0 else has_shift{V}
  def has_vshift{_} = 0  # shift by vector
  def has_vshift{V & hasarch{'AVX2'} & sse_avx{V} & ei{V} & ew{V}>=32} = 1
  def has_vrsh{V} = if (eltype{V}==i64) 0 else has_vshift{V}

  def has_eq{_} = 0  # equals, integer only
  def has_eq{V & hasarch{'SSE2'  } & sse{V}} = width{eltype{V}}<=32
  def has_eq{V & hasarch{'SSE4.2'} & sse{V}} = 1
  def has_eq{V & hasarch{'AVX2'  } & avx{V}} = 1
  def has_gt{V} = if (issigned{eltype{V}}) has_eq{V} else 0

  def has_cmp_flt{_} = 0  # float comparisons with cmpeq, etc.
  def has_cmp_flt{V==[4]f32 & hasarch{'SSE'}} = 1
  def has_cmp_flt{V & hasarch{'SSE2'} & sse{V} & ef{V}} = 1
  def has_cmp_flt{V & hasarch{'AVX' } & avx{V} & ef{V}} = 1

  def has_float{_} = 0  # div, square root
  def has_float{V==[4]f32 & hasarch{'SSE' }} = 1
  def has_float{V==[2]f64 & hasarch{'SSE2'}} = 1
  def has_float{V & hasarch{'AVX'} & avx{V} & ef{V}} = 1
  # floor, ceiling, round
  def has_round{V} = if (hasarch{'SSE4.1'}) has_float{V} else 0

  # abs, sign, avg
  def has_int_op{V, arch_s, q, w} = {
    def check_el{T} = if (width{T}<=w) q==quality{T} else 0
    if (sse_avx{V} and hasarch{if (sse{V}) arch_s else 'AVX2'}) check_el{eltype{V}} else 0
  }
}
