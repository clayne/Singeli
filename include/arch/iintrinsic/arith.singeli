local {
  include 'skin/c'
  def num{x} = is{'number',kind{x}}

  def fmt_p{T, ...s} = {
    if (isfloat{T}) {
      if (width{T}==32) 'ps' else 'pd'
    } else {
      def sgn = if (tuplen{s}==1) tupsel{0,s} else issigned{T}
      merge{'ep', if (sgn) 'i' else 'u', fmtnat{width{T}}}
    }
  }
  def fmt_p{T, w & isint{T} & w>1} = merge{'si', fmtnat{w}}
  def intrin{name, V, ...s} = {
    def w = width{V}
    def fw = if (w<=128) '' else fmtnat{w}
    merge{'_mm', fw, '_', name, '_', fmt_p{eltype{V}, ...s}}
  }
  def intrin_b{name, V} = intrin{name, V, width{V}}

  def sse{V} = 128==width{V}
  def avx{V} = 256==width{V}
  def sse_avx{V} = __or{...tup{128,256}==width{V}}
  def ef{V} = isfloat{eltype{V}}
  def ei{V} = isint  {eltype{V}}
  def ew{V} = width  {eltype{V}}

  def uns{V} = [vcount{V}]primtype{'u', ew{V}}

  def go{V} = if ('vector'==typekind{V}) u1!=eltype{V} else 0
}

def __and   {a:V, b:V & go{V} & has_bitwise{V}} = emit{V, intrin_b{'and'   ,V}, a, b}
def __or    {a:V, b:V & go{V} & has_bitwise{V}} = emit{V, intrin_b{'or'    ,V}, a, b}
def __xor   {a:V, b:V & go{V} & has_bitwise{V}} = emit{V, intrin_b{'xor'   ,V}, a, b}
def __andnot{a:V, b:V & go{V} & has_bitwise{V}} = emit{V, intrin_b{'andnot',V}, a, b}

def __add {a:V, b:V & go{V} & has_arith{V}}  = emit{V, intrin{'add', V,1}, a, b}
def __sub {a:V, b:V & go{V} & has_arith{V}}  = emit{V, intrin{'sub', V,1}, a, b}
def __adds{a:V, b:V & go{V} & has_satur{V}}  = emit{V, intrin{'adds',V  }, a, b}
def __subs{a:V, b:V & go{V} & has_satur{V}}  = emit{V, intrin{'subs',V  }, a, b}
def __min {a:V, b:V & go{V} & has_minmax{V}} = emit{V, intrin{'min', V  }, a, b}
def __max {a:V, b:V & go{V} & has_minmax{V}} = emit{V, intrin{'max', V  }, a, b}
def __mul {a:V, b:V & go{V} & has_mul{V}}    = emit{V, intrin{if (ef{V}) 'mul' else 'mullo', V,1}, a, b}

def __shl{a:V, b & num{b} & go{V} & has_shift{V}} = emit{V, intrin{'slli',V,1}, a, b}
def __shr{a:V, b & num{b} & go{V} & has_rsh  {V}} = emit{V, intrin{if (issigned{eltype{V}}) 'srai' else 'srli',V,1}, a, b}
def __shl_hom{a:V, b:V & go{V} & has_shift{V}} = emit{V, intrin{'sll',V,1}, a, b}
def __shr_hom{a:V, b:V & go{V} & has_rsh  {V}} = emit{V, intrin{if (issigned{eltype{V}}) 'sra' else 'srl',V,1}, a, b}
def __shl{a:V, b:V & go{V} & has_vshift{V}} = emit{V, intrin{'sllv',V,1}, a, b}
def __shr{a:V, b:V & go{V} & has_vrsh  {V}} = emit{V, intrin{if (issigned{eltype{V}}) 'srav' else 'srlv',V,1}, a, b}

def __eq{a:V, b:V & go{V} & has_eq{V}} = emit{uns{V}, intrin{'cmpeq',V,1}, b, a}
def __gt{a:V, b:V & go{V} & has_gt{V}} = emit{uns{V}, intrin{'cmpgt',V  }, a, b}
def __lt{a:V, b:V & go{V} & has_gt{V}} = emit{uns{V}, intrin{'cmpgt',V  }, b, a}

local def cmp_flt{V, a, b, name, num} = {
  def c = if (sse{V}) emit{V, intrin{merge{'cmp',name}, V}, a, b}
          else        emit{V, intrin{'cmp', V}, a, b, num}
  # Return unsigned int even though intrinsics use floats
  def U = uns{V}
  emit{U, intrin_b{merge{'cast',fmt_p{eltype{V}}}, U}, c}
}
def __eq{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'eq' ,  0}
def __ne{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'neq',  4}
def __gt{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'gt' , 30}
def __ge{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'ge' , 29}
def __lt{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'lt' , 17}
def __le{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'le' , 18}

def __abs {a:V & go{V} & has_abs {V}} = emit{V, intrin{'abs' , V}, a}
def __sqrt{a:V & go{V} & has_float{V}} = emit{V, intrin{'sqrt', V}, a}
def __div  {a:V, b:V & go{V} & has_float{V}} = emit{V, intrin{'div',   V}, a, b}
def __floor{a:V, b:V & go{V} & has_round{V}} = emit{V, intrin{'floor', V}, a, b}
def __ceil {a:V, b:V & go{V} & has_round{V}} = emit{V, intrin{'ceil',  V}, a, b}
def __round{a:V, b:V & go{V} & has_round{V}} = emit{V, intrin{'round', V}, a, b}

def __avg {a:V, b:V & go{V} & has_int_op{V,'SSE2' ,'u',16}} = emit{V, intrin{'avg' ,V}, a, b}
def __sign{a:V      & go{V} & has_int_op{V,'SSSE3','i',32}} = emit{V, intrin{'sign',V}, a}

local {
  def has_bitwise{_} = 0  # and, or, xor, andnot
  def has_bitwise{V==[4]f32 & hasarch{'SSE'}} = 1
  def has_bitwise{V & hasarch{'SSE2'} & sse{V}} = 1
  def has_bitwise{V & hasarch{'AVX'} & avx{V} & ef{V}} = 1
  def has_bitwise{V & hasarch{'AVX2'} & avx{V}} = 1

  def has_arith{_} = 0  # add, subtract
  def has_arith{V==[4]f32 & hasarch{'SSE'}} = 1
  def has_arith{V & hasarch{'SSE2'} & sse{V}} = 1
  def has_arith{V & hasarch{'AVX'} & avx{V} & ef{V}} = 1
  def has_arith{V & hasarch{'AVX2'} & avx{V}} = 1

  def has_satur{_} = 0  # saturating add/subtract
  def has_satur{V & hasarch{'SSE2'} & sse{V}} = ew{V}<=16
  def has_satur{V & hasarch{'AVX2'} & avx{V}} = ew{V}<=16

  def has_minmax{_} = 0  # min, max
  def has_minmax{V==[ 4]f32 & hasarch{'SSE' }} = 1
  def has_minmax{V==[ 2]f64 & hasarch{'SSE2'}} = 1
  def has_minmax{V==[ 8]i16 & hasarch{'SSE2'}} = 1
  def has_minmax{V==[16]u8  & hasarch{'SSE2'}} = 1
  def avx_minmax{T} = if (isfloat{T}) 1 else width{T}<=32
  def has_minmax{V & hasarch{'SSE4.1'} & sse{V}} = avx_minmax{eltype{V}}
  def has_minmax{V & hasarch{'AVX'} & avx{V} & ef{V}} = 1
  def has_minmax{V & hasarch{'AVX2'} & avx{V}} = avx_minmax{eltype{V}}

  def has_mul{_} = 0  # same-width multiply (mullo for ints)
  def has_mul{V==[4]f32 & hasarch{'SSE' }} = 1
  def has_mul{V & hasarch{'SSE2'  } & sse{V} & ef{V}} = 1
  def has_mul{V & hasarch{'SSE2'  } & sse{V} & ew{V}==16} = 1
  def has_mul{V & hasarch{'SSE4.1'} & sse{V} & ew{V}==32} = 1
  def has_mul{V & hasarch{'AVX'   } & avx{V} & ef{V}} = 1
  def has_mul{V & hasarch{'AVX2'  } & avx{V} & ew{V}<=32 & ew{V}>=16} = 1

  def has_shift{_} = 0  # shift by scalar
  def has_shift{V & hasarch{'SSE2'} & sse{V} & ei{V} & ew{V}>=16} = 1
  def has_shift{V & hasarch{'AVX2'} & avx{V} & ei{V} & ew{V}>=16} = 1
  def has_rsh{V} = if (eltype{V}==i64) 0 else has_shift{V}
  def has_vshift{_} = 0  # shift by vector
  def has_vshift{V & hasarch{'AVX2'} & sse_avx{V} & ei{V} & ew{V}>=32} = 1
  def has_vrsh{V} = if (eltype{V}==i64) 0 else has_vshift{V}

  def has_eq{_} = 0  # equals, integer only
  def has_eq{V & hasarch{'SSE2'  } & sse{V}} = width{eltype{V}}<=32
  def has_eq{V & hasarch{'SSE4.2'} & sse{V}} = 1
  def has_eq{V & hasarch{'AVX2'  } & avx{V}} = 1
  def has_gt{V} = if (issigned{eltype{V}}) has_eq{V} else 0

  def has_cmp_flt{_} = 0  # float comparisons with cmpeq, etc.
  def has_cmp_flt{V==[ 4]f32 & hasarch{'SSE'}} = 1
  def has_cmp_flt{V & hasarch{'SSE2'} & sse{V} & ef{V}} = 1
  def has_cmp_flt{V & hasarch{'AVX' } & avx{V} & ef{V}} = 1

  def has_absi{_} = 0  # absolute value, signed integer only
  def has_absi{V & hasarch{'SSSE3'} & sse{V}} = width{eltype{V}}<=32
  def has_absi{V & hasarch{'AVX2' } & avx{V}} = width{eltype{V}}<=32
  def has_abs{V} = if (issigned{eltype{V}}) has_absi{V} else 0

  def has_float{_} = 0  # div, square root
  def has_float{V==[4]f32 & hasarch{'SSE' }} = 1
  def has_float{V==[2]f64 & hasarch{'SSE2'}} = 1
  def has_float{V & hasarch{'AVX'} & avx{V} & ef{V}} = 1
  # floor, ceiling, round
  def has_round{V} = if (hasarch{'SSE4.1'}) has_float{V} else 0

  # avg, sign
  def has_int_op{V, arch_s, q, w} = {
    def check_el{T} = if (width{T}<=w) q==quality{T} else 0
    if (sse_avx{V} and hasarch{if (sse{V}) arch_s else 'AVX2'}) check_el{eltype{V}} else 0
  }
}
