local {
  include 'skin/c'
  def num{x} = is{'number',kind{x}}

  def fmt_p{T, ...s} = {
    if (isfloat{T}) {
      if (width{T}==32) 'ps' else 'pd'
    } else {
      def sgn = if (tuplen{s}==1) tupsel{0,s} else issigned{T}
      merge{'ep', if (sgn) 'i' else 'u', fmtnat{width{T}}}
    }
  }
  def fmt_p{T, w & isint{T} & w>1} = merge{'si', fmtnat{w}}
  def intrin{name, V, ...s} = {
    def w = width{V}
    def fw = if (w<=128) '' else fmtnat{w}
    merge{'_mm', fw, '_', name, '_', fmt_p{eltype{V}, ...s}}
  }
  def intrin_b{name, V} = intrin{name, V, width{V}}

  def sse{V} = 128==width{V}
  def avx{V} = 256==width{V}
  def ef{V} = isfloat{eltype{V}}
  def ei{V} = isint  {eltype{V}}
  def ew{V} = width  {eltype{V}}

  def uns{V} = [vcount{V}]primtype{'u', ew{V}}

  def go{V} = if ('vector'==typekind{V}) u1!=eltype{V} else 0
}

def __and   {a:V, b:V & go{V} & has_bitwise{V}} = emit{V, intrin_b{'and'   ,V}, a, b}
def __or    {a:V, b:V & go{V} & has_bitwise{V}} = emit{V, intrin_b{'or'    ,V}, a, b}
def __xor   {a:V, b:V & go{V} & has_bitwise{V}} = emit{V, intrin_b{'xor'   ,V}, a, b}
def __andnot{a:V, b:V & go{V} & has_bitwise{V}} = emit{V, intrin_b{'andnot',V}, a, b}

def __add {a:V, b:V & go{V} & has_arith{V}}  = emit{V, intrin{'add', V,1}, a, b}
def __sub {a:V, b:V & go{V} & has_arith{V}}  = emit{V, intrin{'sub', V,1}, a, b}
def __adds{a:V, b:V & go{V} & has_satur{V}}  = emit{V, intrin{'adds',V  }, a, b}
def __subs{a:V, b:V & go{V} & has_satur{V}}  = emit{V, intrin{'subs',V  }, a, b}
def __min {a:V, b:V & go{V} & has_minmax{V}} = emit{V, intrin{'min', V  }, a, b}
def __max {a:V, b:V & go{V} & has_minmax{V}} = emit{V, intrin{'max', V  }, a, b}
def __mul {a:V, b:V & go{V} & has_mul{V}}    = emit{V, intrin{if (ef{V}) 'mul' else 'mullo', V,1}, a, b}

def __shl{a:V, b & num{b} & go{V} & has_shift_imm{V}} = emit{V, intrin{'slli',V,1}, a, b}
def __shr{a:V, b & num{b} & go{V} & has_rsh_imm  {V}} = emit{V, intrin{if (issigned{eltype{V}}) 'srai' else 'srli',V,1}, a, b}

def __eq{a:V, b:V & go{V} & has_eq{V}} = emit{uns{V}, intrin{'cmpeq',V,1}, b, a}
def __gt{a:V, b:V & go{V} & has_gt{V}} = emit{uns{V}, intrin{'cmpgt',V  }, a, b}
def __lt{a:V, b:V & go{V} & has_gt{V}} = emit{uns{V}, intrin{'cmpgt',V  }, b, a}

local def cmp_flt{V, a, b, name, num} = {
  def c = if (sse{V}) emit{V, intrin{merge{'cmp',name}, V}, a, b}
          else        emit{V, intrin{'cmp', V}, a, b, num}
  # Return unsigned int even though intrinsics use floats
  emit{uns{V}, intrin_b{merge{'cast',fmt_p{V}}, V}, c}
}
def __eq{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'eq' ,  0}
def __ne{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'neq',  4}
def __gt{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'gt' , 30}
def __ge{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'ge' , 29}
def __lt{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'lt' , 17}
def __le{a:V, b:V & go{V} & has_cmp_flt{V}} = cmp_flt{V, a, b, 'le' , 18}

def __abs {a:V & go{V} & has_abs {V}} = emit{V, intrin{'abs' , V}, a}
def __sqrt{a:V & go{V} & has_sqrt{V}} = emit{V, intrin{'sqrt', V}, a}

local {
  def has_bitwise{_} = 0  # and, or, xor, andnot
  def has_bitwise{V==[4]f32 & hasarch{'SSE'}} = 1
  def has_bitwise{V & hasarch{'SSE2'} & sse{V}} = 1
  def has_bitwise{V & hasarch{'AVX'} & avx{V} & ef{V}} = 1
  def has_bitwise{V & hasarch{'AVX2'} & avx{V}} = 1

  def has_arith{_} = 0  # add, subtract
  def has_arith{V==[4]f32 & hasarch{'SSE'}} = 1
  def has_arith{V & hasarch{'SSE2'} & sse{V}} = 1
  def has_arith{V & hasarch{'AVX'} & avx{V} & ef{V}} = 1
  def has_arith{V & hasarch{'AVX2'} & avx{V}} = 1

  def has_satur{_} = 0  # saturating add/subtract
  def has_satur{V & hasarch{'SSE2'} & sse{V}} = ew{V}<=16
  def has_satur{V & hasarch{'AVX2'} & avx{V}} = ew{V}<=16

  def has_minmax{_} = 0  # min, max
  def has_minmax{V==[ 4]f32 & hasarch{'SSE' }} = 1
  def has_minmax{V==[ 2]f64 & hasarch{'SSE2'}} = 1
  def has_minmax{V==[ 8]i16 & hasarch{'SSE2'}} = 1
  def has_minmax{V==[16]u8  & hasarch{'SSE2'}} = 1
  def avx_minmax{T} = if (isfloat{T}) 1 else width{T}<=32
  def has_minmax{V & hasarch{'SSE4.1'} & sse{V}} = avx_minmax{eltype{V}}
  def has_minmax{V & hasarch{'AVX'} & avx{V} & ef{V}} = 1
  def has_minmax{V & hasarch{'AVX2'} & avx{V}} = avx_minmax{eltype{V}}

  def has_mul{_} = 0  # same-width multiply (mullo for ints)
  def has_mul{V==[4]f32 & hasarch{'SSE' }} = 1
  def has_mul{V & hasarch{'SSE2'  } & sse{V} & ef{V}} = 1
  def has_mul{V & hasarch{'SSE2'  } & sse{V} & ew{V}==16} = 1
  def has_mul{V & hasarch{'SSE4.1'} & sse{V} & ew{V}==32} = 1
  def has_mul{V & hasarch{'AVX'   } & avx{V} & ef{V}} = 1
  def has_mul{V & hasarch{'AVX2'  } & avx{V} & ew{V}<=32 & ew{V}>=16} = 1

  def has_shift_imm{_} = 0  # shift by immediate
  def has_shift_imm{V & hasarch{'SSE2'} & sse{V} & ei{V} & ew{V}>=16} = 1
  def has_shift_imm{V & hasarch{'AVX2'} & avx{V} & ei{V} & ew{V}>=16} = 1
  def has_rsh_imm{V} = if (eltype{V}==i64) 0 else has_shift_imm{V}

  def has_eq{_} = 0  # equals, integer only
  def has_eq{V & hasarch{'SSE2'  } & sse{V}} = width{eltype{V}}<=32
  def has_eq{V & hasarch{'SSE4.2'} & sse{V}} = 1
  def has_eq{V & hasarch{'AVX2'  } & avx{V}} = 1
  def has_gt{V} = if (issigned{eltype{V}}) has_eq{V} else 0

  def has_cmp_flt{_} = 0  # float comparisons with cmpeq, etc.
  def has_cmp_flt{V==[ 4]f32 & hasarch{'SSE'}} = 1
  def has_cmp_flt{V & hasarch{'SSE2'} & sse{V} & ef{V}} = 1
  def has_cmp_flt{V & hasarch{'AVX' } & avx{V} & ef{V}} = 1

  def has_absi{_} = 0  # absolute value, signed integer only
  def has_absi{V & hasarch{'SSSE3'} & sse{V}} = width{eltype{V}}<=32
  def has_absi{V & hasarch{'AVX2' } & avx{V}} = width{eltype{V}}<=32
  def has_abs{V} = if (issigned{eltype{V}}) has_absi{V} else 0

  def has_sqrt{_} = 0  # square root
  def has_sqrt{V==[4]f32 & hasarch{'SSE' }} = 1
  def has_sqrt{V==[2]f64 & hasarch{'SSE2'}} = 1
  def has_sqrt{V & hasarch{'AVX'} & avx{V} & ef{V}} = 1
}
