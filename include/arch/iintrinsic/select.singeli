local {
  include 'skin/cop'
  include 'util/kind'
  oper ~~ reinterpret infix right 55
  def base{b,{}} = 0; def base{b,{h,...t}} = h + b*base{b,t}

  def all = match {
    {{t}} => t
    {t} => { def h=length{t}>>1; all{slice{t,0,-h} & slice{t,h}} }
  }

  def fmt_p{T} = {
    if (isfloat{T}) {
      if (width{T}==32) 'ps' else 'pd'
    } else {
      merge{'epi', fmtnat{width{T}}} # No unsigned instructions here
    }
  }
  def intrin_g{get_typ}{name, V} = {
    def w = width{V}
    def fw = if (w<=128) '' else fmtnat{w}
    merge{'_mm', fw, '_', name, '_', get_typ{V}}
  }
  def intrin = intrin_g{{[_]T} => fmt_p{T}}
  def intrin_b = intrin_g{{V=[_]T} => {
    if (isint{T}) merge{'si',fmtnat{width{V}}} else fmt_p{T}
  }}

  # Only need to cast if element type class changes
  def class{T} = if (isfloat{T}) T else i8  # i8 represents any int
  def call_cast{gen, T, V=[_]E, ...vs} = {
    if (class{E} == class{T}) gen{...vs}
    else V~~gen{...each{~~{[width{V}/width{T}]T, .}, vs}}
  }
}

# 16-bit shuffles on half-words don't quite fit vec_shuffle
local def vec_shuffle16_impl{suff, vec:V, ind} = {
  emit{V, intrin{merge{'shuffle', suff}, [width{V}/16]i16}, vec, base{4, ind}}
}
local def has_sh16{w} = (w==128 and hasarch{'SSE2'}) or (w==256 and hasarch{'AVX2'})
local def vec_shuffle_part{part}{vec:V=[_]_, {...ind} if has_sh16{width{V}} and length{ind}==4 and all{(ind>=0) & (ind<4)}} = {
  call_cast{vec_shuffle16_impl{part, ., ind}, i16, V, vec}
}
def vec_shuffle16_lo = vec_shuffle_part{'lo'}
def vec_shuffle16_hi = vec_shuffle_part{'hi'}

# General implementation for constant indices
local def vec_shuffle_impl{T, sel_n, val={_:V, ..._}, ind} = {
  def pos = all{ind >= 0}
  def w = width{T}
  def wv= width{V}
  def sel_width = sel_n * w
  def ind_width = length{ind} * w
  def 0 = wv % ind_width
  # Index expansion and instruction calls
  def get_ind{sel_n, n, ind} = {
    def exp{i} = if (n <= length{i}) i else exp{merge{i, i}}
    def off{i} = i + (range{length{i}} & -sel_n)
    off{exp{ind}}
  }
  def shuf_sub{I, name, ind, val} = {
    emit{V, intrin{name, [wv/width{I}]I}, ...val, ind}
  }
  def shuf{name, n, fmt} = shuf_sub{T, name, fmt{get_ind{sel_n, n, ind}}, val}
  def shuf{name, E, n, fmt} = {
    def e = w / width{E}
    def wi = if (e == 1) ind else merge{...each{+{.,range{e}}, e*ind}}
    shuf_sub{E, name, fmt{get_ind{e*sel_n, n, wi}}, val}
  }
  def shuf_base{...a, n   } = shuf{...a, n, base{n, .}}
  def shuf_make{...a, n, T} = shuf{...a, n, vec_make{[n]T, .}}
  # Arch-specific cases
  if (2 == length{val}) {
    def 1 = isfloat{T} and wv >= 128 and ind_width <= 128
    shuf_base{'shuffle', 128 / w}
  } else if (wv < 128) {
    def 1 = wv == 64 and isint{T} and w >= 16 and pos
    shuf_base{'shuffle', 4}
  } else if (sel_width == 256) {
    def 1 = hasarch{'AVX2'} and pos
    match (w) {
      {32} => shuf_make{'permutevar8x32', 8, u32}
      {64} => shuf_base{'permute4x64', 4}
    }
  } else if (isfloat{T}) {
    if (ind_width == 256) {
      def 1 = hasarch{'AVX'} and pos
      def n = 256 / w
      def U = [n]primtype{'u', w}
      shuf{'permutevar', n, {i} => vec_make{U, (w/32)*i}}
    } else {
      def n = 128 / w
      if (hasarch{'AVX'}) shuf_base{'permute', n}
      else shuf_sub{T, 'shuffle', base{n, get_ind{sel_n, n, ind}}, merge{val,val}}
    }
  } else { # isint{T}
    def 1 = hasarch{'SSE2'}
    match () {
      {if w >= 32 and pos}  => shuf_base{'shuffle', i32, 4}
      {if hasarch{'SSSE3'}} => shuf_make{'shuffle', i8, wv/8, i8}
      {if w >= 16 and sel_width <= 64 and pos} => {
        def io = get_ind{w/16 * sel_n, 4, ind}
        def i = io - (range{length{io}} & -4) # Avoid passing offset indices to shufflehi
        def fi{v, s, ...bnd} = vec_shuffle16_impl{s, v, slice{i, ...bnd}}
        fi{fi{...val, 'lo',0,4}, 'hi',-4}
      }
    }
  }
}

# Process parameters
local def vec_shuffle_proc{...spec, V=[_]vT, vals, {...inds}} = {
  # inds doesn't have the element type so it comes from spec or val
  def T = match (...spec) {
    {[_]T} => T; {T if ktyp{T}} => T
    {n if knum{n}} => vT; {} => vT
  }
  # sel_n is the number of indices in a selection unit
  # It can be specified by spec as a number or length of vector type
  # and/or by the length of each list in nested inds
  def spec_n = match (...spec) {
    {[k]_} => tup{k}; {k if knum{k}} => tup{k}; {..._} => tup{}
  }
  def {ind_n, ind} = match (inds) {
    {{{...t}, ..._}} => {
      def l = length{t}
      def 1 = all{l == each{length, inds}}
      tup{tup{l}, merge{...inds}}
    }
    {_} => {
      each{{s} => { def 0 = length{inds} % s }, spec_n}
      tup{tup{}, inds}
    }
  }
  def sel_n = match(...spec_n, ...ind_n) {  # Shuffle unit from spec and nested indices must match
    {n,n} => n; {n} => n; {} => length{ind}
  }
  def 1 = all{ind < sel_n}
  def shuf{...v} = vec_shuffle_impl{T, sel_n, v, ind}
  call_cast{shuf, T, V, ...vals}
}

# For convenience, allow indices to be written directly without tup
def vec_shuffle{val, ...inds if 1 < length{inds}} = vec_shuffle{val, inds}
def vec_shuffle{spec if knum{spec} or ktyp{spec}, val, ...inds if 1 < length{inds}} = vec_shuffle{spec, val, inds}
# Main definitions
def vec_shuffle{...spec, val:    V=[_]_      , {...inds}} = vec_shuffle_proc{...spec, V, tup{val}, inds}
def vec_shuffle{...spec, vals={_:V=[_]_, _:V}, {...inds}} = vec_shuffle_proc{...spec, V, vals,     inds}

# Variable indices: not many cases to support
def vec_shuffle{...spec, val:V=[vk]vT, ind:[ik]I if isint{I}} = {
  # Selection type and size can be set by spec, or come from ind
  # But element quality comes from val if possible
  def wi = width{I}
  def ty{} = if (wi < 32) I else primtype{quality{vT}, wi}
  def {sel_n, T} = match (...spec) {
    {[n]T}         => tup{ n,T}
    {T if ktyp{T}} => tup{ik,T}
    {n if knum{n}} => tup{ n,ty{}}
    {}             => tup{ik,ty{}}
  }
  def 1 = wi == width{T}
  def 0 = ik % sel_n
  def name = match (sel_n, width{T}) {
    {16, 8 if hasarch{'SSSE3'}} => 'shuffle'
    {4, 32 if hasarch{'AVX'} and isfloat{T}} => 'permutevar'
    # no 2, 64: permutevar_pd scales indices!
    {8, 32 if hasarch{'AVX2'}} => 'permutevar8x32'
  }
  def S = [width{V}/width{T}]T
  def shuf = emit{., intrin{name, S}, ., ind}
  if (class{T} == class{vT}) shuf{V, val}
  else                  V ~~ shuf{S, S ~~ val}
}

# Next-to-last index bit is used, so index has to be multiplied by 2
def vec_shuffle_64_scaled{val:V=[k](f64), ind:[k]I if isint{I} and width{I}==64 and hasarch{'AVX'}} = {
  emit{V, intrin{'permutevar_pd', V}, val, ind}
}
def vec_shuffle_64_scaled{val:V=[_]T, ind if T != f64} = {
  V ~~ vec_shuffle_64_scaled{[width{V}/64]f64~~val, ind}
}

# Selects as 4 unified lanes
def vec_select{v={a:V=[_]T, b:V}, ind={_,_} if 256==width{V} and hasarch{'AVX'} and all{(ind>=0) & (ind<4)}} = {
  def q = if (isint{T} and hasarch{'AVX2'}) 'x' else 'f'
  def name = merge{'permute2', q, '128'}
  emit{V, intrin_b{name, V}, a, b, base{16, ind}}
}
